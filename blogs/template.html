<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vapour Dev - My Works</title>
    <link rel="stylesheet" href="../styles/light/v0.css">
    <link rel="shortcut icon" href="../assets/untitled.png" type="image/png">
    <script data-ad-client="ca-pub-3936125256128056" async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
</head>
<body>
    
    <div class="global-navbar">
        <div class="inner-global-navbar">
            
            <div class="logo-area">
                <a href="./index.html"><h1 class="logo-text">Vapour Dev</h1></a>
            </div>

            <div id="humburgerDropDown" class="links-area">

                <ul>

                    <li class="active">
                        <a href="./blogs.html">Blogs</a>
                    </li>

                    <li class="">
                        <a href="./works.html">My Works</a>
                    </li>

                    <li class="">
                        <a href="./contact.html">Contact Me</a>
                    </li>

                    <li class="">
                        <a href="./about.html">About Me</a>
                    </li>
                
                </ul>

            </div>

            <div id="btnHumburger" class="humburger">
                <div></div>
                <div></div>
                <div></div>
            </div>

        </div>
    </div>

    <div class="trigger-contact-us">

        <div class="inner-trigger">

            <a href="mailto:vapourdev@gmail.com">VapourDev@gmail.com</a>

        </div>

    </div>


    <div class="page-content mr-up-10">

        <div class="inner-page-content">

            <div class="my-info">

                <h1>Blog.</h1>
                <h1 class="info-logo">VapourDev</h1>

                <div class="acc">

                    <a href="mailto:vapourdev@gmail.com">Mail Me &RightAngleBracket;</a>

                    <a href="https://www.github.com/vapourdev">Github &RightAngleBracket;</a>

                </div>

            </div>




            <div class="page-identity">
                <span>
                    <a href="../index.html">Home &RightAngleBracket;</a>
                    <a href="../blogs.html">Blogs &RightAngleBracket;</a>
                    <a href="template.html" class="active">UEFI : Getting EDID Information &RightAngleBracket;</a>
                </span>
            </div>

            <div class="blog-post">

                <div class="blog-title">
                    <h1>UEFI : Getting EDID Information</h1>
                </div>

                <div class="blog-content">

                    <div class="blog-sections">
                        <ul>
                            <li><a href="#intro">Introduction</a></li>
                            <li><a href="#intro">Setting up...</a></li>
                            <li><a href="#intro">Build Process</a></li>
                            <li><a href="#intro">Getting EDID Info</a></li>
                            <li><a href="#intro">Testing It</a></li>
                            <li><a href="#intro">Finish</a></li>
                        </ul>
                    </div>

                    <div class="blog-text">

                        <h1>Introduction</h1>

                        <p>

                            I have had a very rudimentary UEFI utility for taking screenshots from within the UEFI shell since circa 2012. Recently, I decided to update and polish this utility. The end result is two seperate screenshot capturing utilities – a UEFI shell command line utility (ScreenShot.efi) and a UEFI driver-based screenshot utility (ScreenshotDriver.efi). These are both available on GitHub in my UEFI-Utilities-2019 repository.

In this post, I describe the key functions (AKA components) of these two utilities. Note that this post loads slowly because of the inclusion of some fullscreen BMP images generated by the utilities – so apologies in advance.

This is the key snippet of code in both utilities:
Status = ShowStatus( Gop, Yellow, StartX, StartY, Width, Height ); 
gBS->Stall(500*1000);
Status = SnapShot( Gop , StartX, StartY, Width, Height );
if (EFI_ERROR(Status)) {
    Status = ShowStatus( Gop, Red, StartX, StartY, Width, Height ); 
} else {
    Status = ShowStatus( Gop, Lime, StartX, StartY, Width, Height ); 
}

This code displays 4 small 10 pixel squares (size is configurable) designating the top left, top right, bottom left and bottom right of the rectangular area of the screen which will be snapshot-ed. Initially the squares are yellow. They change to green if the screenshot is successfully saved to a file, otherwise they change to red to denote that an error occurred and no screenshot was saved.

Here is the source code for ShowStatus function: </p>

<textarea>

    EFI_STATUS
    ShowStatus( EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop,
                UINT8 Color, 
                UINTN StartX, 
                UINTN StartY,
                UINTN Width, 
                UINTN Height ) 
    {
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL Square[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE];
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL BackupTL[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE];
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL BackupTR[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE];
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL BackupBL[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE];
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL BackupBR[STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE];
        
        // set square color
        for (UINTN i = 0 ; i < STATUS_SQUARE_SIDE * STATUS_SQUARE_SIDE; i++) {
            Square[i].Blue = EfiGraphicsColors[Color].Blue;
            Square[i].Green = EfiGraphicsColors[Color].Green;
            Square[i].Red = EfiGraphicsColors[Color].Red;
            Square[i].Reserved = 0x00;
        }
        
        Width = Width - STATUS_SQUARE_SIDE -1;
        Height = Height - STATUS_SQUARE_SIDE -1;
        
        // backup current squares
        Gop->Blt(Gop, BackupTL, EfiBltVideoToBltBuffer, StartX, StartY, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupTR, EfiBltVideoToBltBuffer, StartX + Width, StartY, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupBL, EfiBltVideoToBltBuffer, StartX, StartY + Height, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupBR, EfiBltVideoToBltBuffer, StartX + Width, StartY + Height, 0, 0, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
            
        // draw status square
        Gop->Blt(Gop, Square, EfiBltBufferToVideo, 0, 0, StartX, StartY, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, Square, EfiBltBufferToVideo, 0, 0, StartX + Width, StartY, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, Square, EfiBltBufferToVideo, 0, 0, StartX, StartY + Height, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, Square, EfiBltBufferToVideo, 0, 0, StartX + Width, StartY + Height, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
            
        // wait 500ms
        gBS->Stall(500*1000);
            
        // restore squares from backups
        Gop->Blt(Gop, BackupTL, EfiBltBufferToVideo, 0, 0, StartX, StartY, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupTR, EfiBltBufferToVideo, 0, 0, StartX + Width, StartY, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupBL, EfiBltBufferToVideo, 0, 0, StartX, StartY + Height, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        Gop->Blt(Gop, BackupBR, EfiBltBufferToVideo, 0, 0, StartX + Width, StartY + Height, STATUS_SQUARE_SIDE, STATUS_SQUARE_SIDE, 0);
        
        return EFI_SUCCESS;
    }

    As you can see, it makes extensive use of the GOP (Graphic Output Protocol) blt (block transfer) functionality to copy data between the video framebuffer and allocated temporary memory using the EfiBltVideoToBltBuffer and EfiBltBufferToVideo parameters.

    Here is the source code for the function that takes the actual screenshot:
    EFI_STATUS
    SnapShot( EFI_GRAPHICS_OUTPUT_PROTOCOL *Gop, 
            UINTN                        StartX, 
            UINTN                        StartY,
            UINTN                        Width, 
            UINTN                        Height ) 
    {
        EFI_GRAPHICS_OUTPUT_BLT_PIXEL *BltBuffer = NULL;
        EFI_STATUS Status = EFI_SUCCESS;
        UINTN      ImageSize;  

        ImageSize = Width * Height;
                
        // allocate memory for snapshot
        BltBuffer = AllocateZeroPool( sizeof(EFI_GRAPHICS_OUTPUT_BLT_PIXEL) * ImageSize );
        if (BltBuffer == NULL) {
            Print(L"ERROR: BltBuffer. No memory resources\n");
            return EFI_OUT_OF_RESOURCES;
        }

        // take screenshot
        Status = Gop->Blt( Gop, BltBuffer, EfiBltVideoToBltBuffer, StartX, StartY, 0, 0, Width, Height, 0 );
        if (EFI_ERROR(Status)) {
            Print(L"ERROR: Gop->Blt [%d]\n", Status);
            FreePool( BltBuffer );
            return Status;
        }
                
        PrepareBMPFile( BltBuffer, Width, Height );

        return Status;
    }

</textarea>

<p>

Again, note the use of GOP blt with the EfiBltVideoToBltBuffer parameter to capture the contents of the designated screen area as a 32-bit bitmap into BltBuffer.

The next task after capturing a bitmap of the designated screen area is to create the contents of the BMP file in memory before writting it out to disk. This is done in the PrepareBMPFile function as shown below:
EFI_STATUS
PrepareBMPFile( EFI_GRAPHICS_OUTPUT_BLT_PIXEL *BltBuffer,
                UINT32 Width, 
                UINT32 Height )
{
    EFI_GRAPHICS_OUTPUT_BLT_PIXEL *Pixel;
    BMP_IMAGE_HEADER  *BmpHeader;
    EFI_STATUS        Status = EFI_SUCCESS;
    EFI_TIME          Time;
    CHAR16            FileName[40]; 
    UINT8             *FileData;
    UINTN             FileDataLength;
    UINT8             *ImagePtr;
    UINT8             *ImagePtrBase;
    UINTN             ImageLineOffset;
    UINTN             x, y;

    ImageLineOffset = Width * 3;
    if ((ImageLineOffset % 4) != 0) {
        ImageLineOffset = ImageLineOffset + (4 - (ImageLineOffset % 4));
    }

    // allocate buffer for data
    FileDataLength = sizeof(BMP_IMAGE_HEADER) + Height * ImageLineOffset;
    FileData = AllocateZeroPool( FileDataLength );
    if (FileData == NULL) {
        FreePool( BltBuffer );
        Print(L"ERROR: AllocateZeroPool. No memony resources\n");
        return EFI_OUT_OF_RESOURCES;
    }
    
    // fill header
    BmpHeader = (BMP_IMAGE_HEADER *)FileData;
    BmpHeader->CharB = 'B';
    BmpHeader->CharM = 'M';
    BmpHeader->Size = (UINT32)FileDataLength;
    BmpHeader->ImageOffset = sizeof(BMP_IMAGE_HEADER);
    BmpHeader->HeaderSize = 40;
    BmpHeader->PixelWidth = Width;
    BmpHeader->PixelHeight = Height;
    BmpHeader->Planes = 1;
    BmpHeader->BitPerPixel = 24;
    BmpHeader->CompressionType = 0;
    BmpHeader->XPixelsPerMeter = 0;
    BmpHeader->YPixelsPerMeter = 0;
    
    // fill pixel buffer
    ImagePtrBase = FileData + BmpHeader->ImageOffset;
    for (y = 0; y < Height; y++) {
        ImagePtr = ImagePtrBase;
        ImagePtrBase += ImageLineOffset;
        Pixel = BltBuffer + (Height - 1 - y) * Width;
        
        for (x = 0; x < Width; x++) {
            *ImagePtr++ = Pixel->Blue;
            *ImagePtr++ = Pixel->Green;
            *ImagePtr++ = Pixel->Red;
            Pixel++;
        }
    }

    FreePool(BltBuffer);

    Status = gRT->GetTime(&Time, NULL);
    if (!EFI_ERROR(Status)) {
        UnicodeSPrint( FileName, 62, L"screenshot-%04d%02d%02d-%02d%02d%02d.bmp", 
                       Time.Year, Time.Month, Time.Day, Time.Hour, Time.Minute, Time.Second );
    } else {
        UnicodeSPrint( FileName, 30, L"screenshot.bmp" );
    }
    
    SaveImage( FileName, FileData, FileDataLength );

    FreePool( FileData );

    return Status;
}
Finally the in-memory copy of the BMP file is written out to disk in the current directory by the SaveImage function:
EFI_STATUS 
SaveImage( CHAR16 *FileName,
           UINT8  *FileData,
           UINTN  FileDataLength )
{
    SHELL_FILE_HANDLE FileHandle = NULL;
    EFI_STATUS        Status = EFI_SUCCESS;
    CONST CHAR16      *CurDir = NULL;
    CONST CHAR16      *PathName = NULL;
    CHAR16            *FullPath = NULL;
    UINTN             Length = 0;
    
    CurDir = gEfiShellProtocol->GetCurDir(NULL);
    if (CurDir == NULL) {
        Print(L"ERROR: Cannot retrieve current directory\n");
	return EFI_NOT_FOUND;
    }
    PathName = CurDir;
    StrnCatGrow(&FullPath, &Length, PathName, 0);
    StrnCatGrow(&FullPath, &Length, L"\\", 0);
    StrnCatGrow(&FullPath, &Length, FileName, 0);
#ifdef DEBUG
    Print(L"FullPath: [%s]\n", FullPath);
#endif

    Status = gEfiShellProtocol->OpenFileByName( FullPath,
                                                &FileHandle,
                                                EFI_FILE_MODE_READ | EFI_FILE_MODE_WRITE | EFI_FILE_MODE_CREATE);
    if (EFI_ERROR(Status)) {
        Print(L"ERROR: OpenFileByName [%s] [%d]\n", FullPath, Status);
        return Status;
    } 

    // BufferSize = FileDataLength;
    Status = gEfiShellProtocol->WriteFile( FileHandle, 
                                           &FileDataLength, 
                                           FileData );
    gEfiShellProtocol->CloseFile( FileHandle );

    if (EFI_ERROR(Status)) {
        Print(L"ERROR: Saving image to file: %x\n", Status);
    } else {
        Print(L"Successfully saved image to %s\n", FullPath);
    }

    return Status;
}

Could I have directly accessed the screen framebuffer instead of using the functionality provided by GOP’s blt? Absolutely. However I felt that using the GOP blt functionality was probably the more portable approach.



Read more: https://blog.fpmurphy.com/2019/04/two-uefi-screenshot-utilities-added-to-uefi-utilities-2019.html#ixzz6ulqNecmy

                        </p>

                    </div>

                </div>

            </div>

            <div class="posts-holder">

                <div class="inner-posts">

                    <div class="bl-title">
                        <h1>Related Posts</h1>
                    </div>

                    <div class="content">

                        <h1>No any contents yet.</h1>

                    </div>

                </div>

            </div>






            <div class="go">
                <a href="blogs.html">See My Blogs &RightAngleBracket;</a>
            </div>
            
        </div>

    </div>


    <div id="full-image-gallery-view" onclick="hideFullGalleryView()" style="display: none;" class="full-gallery-view">

        <img data-img="./assets/a9f468a00bfeeb705c9fc6ead66f99c2.jpg">
    
    </div>

    <div class="footer-section">

        <div class="inner-footer-section">
    
            <div class="contact-section">
    
                <div class="left-aligned">
    
                    <div class="btns mr-up-10 multi-btns">
                        <span>For Any Quote, Feel Free to</span>
                        <a class="link-btn" href="mailto:vapourdev@gmail.com">Mail Me : VapourDev@gmail.com &RightAngleBracket;</a> <a class="link-btn" href="https://www.github.com/VapourDev">Github/VapourDev &RightAngleBracket;</a>
                    </div>
    
                </div>
    
            </div>
    
            <hr noshade class="seprator-hr mr-up-40">
    
            <div class="footer-links-section mr-up-40">
    
                <div class="inner-footer-links">
    
                    <div class="left-links">
    
                        <h1>Vapour Dev</h1>
    
                    </div>
    
                    <div class="right-links">

                        <a>&copy; Copyright 2021</a>
    
                        <a class="link-btn" href="../privacy.html">Privacy Policy</a>

                        <a class="link-btn" href="../assets/sitemap.xml">Sitemap</a>
    
                    </div>
    
                </div>
    
            </div>
    
        </div>
    
    </div>
    

    <script src="../scripts/app.js"></script>

</body>
</html>
